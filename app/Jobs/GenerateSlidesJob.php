<?php

namespace App\Jobs;

use App\Models\Sermon;
use App\Models\SermonSlide;
use App\Services\SlideBuilderService;
use App\Services\SlideGenerationService;
use Filament\Notifications\Notification;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Http;
use Prism\Prism\Prism;

class GenerateSlidesJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $timeout = 300;

    protected ?array $lastImageSearch = null;

    protected ?array $lastImageAttribution = null;

    public function __construct(
        public ?Sermon $sermon,
        public array $formData,
        public ?string $jobId = null
    ) {}

    public function handle(): void
    {
        $service = new SlideGenerationService;
        $cacheKey = $this->sermon ? "sermon_slides_generation_{$this->sermon->id}" : null;

        try {
            // Extract data from form
            $theme = $this->formData['theme'];
            $themeConfig = config("slides.themes.{$theme}");

            // Get content based on mode
            if ($this->formData['mode'] === 'existing') {
                $title = $this->sermon->title;
                $content = $this->sermon->content;
                $scripture = $this->sermon->primary_scripture;
            } else {
                $title = $this->formData['title'];
                $content = $this->formData['content'];
                $scripture = $this->formData['scripture'] ?? null;
            }

            // Generate slide plan with AI (this happens in background job now)
            if ($this->jobId) {
                $service->updateStatus($this->jobId, 'Creating slide plan with AI...');
            }

            $slidePlan = $this->generateSlidePlan($title, $content, $scripture, $this->formData);

            $totalSlides = $slidePlan['totalSlides'] ?? count($slidePlan['slides']);

            if ($this->jobId) {
                $service->startGeneration($this->jobId, $totalSlides);
            }

            foreach ($slidePlan['slides'] as $index => $slideData) {
                $slideNumber = $slideData['slide_number'] ?? ($index + 1);

                if ($cacheKey) {
                    $this->updateProgress($cacheKey, $slideNumber, $totalSlides, "Processing slide {$slideNumber}");
                }

                if ($this->jobId) {
                    $service->updateStatus($this->jobId, "Processing slide {$slideNumber}");
                }

                // HTML is already generated by the tools
                $htmlContent = $slideData['html_content'];
                $backgroundType = $slideData['background_type'] ?? 'gradient';
                $backgroundValue = $slideData['background_value'] ?? $themeConfig['background'];
                $imageAttribution = null;

                $metadata = [
                    'theme' => $theme,
                    'original_plan' => $slideData,
                ];

                if ($imageAttribution) {
                    $metadata['image_attribution'] = $imageAttribution;
                }

                $slideRecord = null;
                if ($this->sermon) {
                    $slideRecord = SermonSlide::create([
                        'sermon_id' => $this->sermon->id,
                        'slide_number' => $slideNumber,
                        'slide_type' => $slideData['type'] ?? 'content',
                        'html_content' => $htmlContent,
                        'css_styles' => $this->generateSlideStyles($themeConfig),
                        'background_type' => $backgroundType,
                        'background_value' => $backgroundValue,
                        'ai_prompt_history' => [
                            [
                                'timestamp' => now()->toIso8601String(),
                                'action' => 'initial_generation',
                                'prompt' => "Generated from slide plan: {$slideData['title']}",
                            ],
                        ],
                        'metadata' => $metadata,
                    ]);
                }

                if ($this->jobId) {
                    $service->addSlide($this->jobId, [
                        'slide_number' => $slideNumber,
                        'type' => $slideData['type'] ?? 'content',
                        'html_content' => $htmlContent,
                        'background_type' => $backgroundType,
                        'background_value' => $backgroundValue,
                        'total' => $totalSlides,
                    ]);
                }
            }

            if ($cacheKey) {
                $this->updateProgress($cacheKey, $totalSlides, $totalSlides, 'Complete!');
                Cache::put("{$cacheKey}_status", 'completed', now()->addMinutes(5));
            }

            if ($this->jobId) {
                $service->markComplete($this->jobId);
            }

            if ($this->sermon) {
                Notification::make()
                    ->title('Slides Generated Successfully!')
                    ->success()
                    ->body("Created {$totalSlides} slides for {$this->sermon->title}")
                    ->send();
            }
        } catch (\Exception $e) {
            if ($cacheKey) {
                Cache::put("{$cacheKey}_status", 'failed', now()->addMinutes(5));
                Cache::put("{$cacheKey}_error", $e->getMessage(), now()->addMinutes(5));
            }

            if ($this->jobId) {
                $service->markFailed($this->jobId, $e->getMessage());
            }

            Notification::make()
                ->title('Slide Generation Failed')
                ->danger()
                ->body('Error: '.$e->getMessage())
                ->send();

            throw $e;
        }
    }

    protected function generateSlidePlan(string $title, string $content, ?string $scripture, array $formData): array
    {
        $theme = $formData['theme'];
        $themeConfig = config("slides.themes.{$theme}");

        // Create slide builder with tools
        $slideBuilder = new SlideBuilderService($themeConfig);

        $prompt = $this->buildToolBasedPrompt($title, $content, $scripture, $formData, $themeConfig);
        $systemPrompt = $this->buildToolBasedSystemPrompt();

        $modelConfig = config('study-ai.models.text');

        $response = Prism::text()
            ->using($modelConfig['provider'], $modelConfig['model'])
            ->withSystemPrompt($systemPrompt)
            ->withPrompt($prompt)
            ->withTools($slideBuilder->getTools())
            ->withMaxSteps(50) // Allow multiple tool calls
            ->withMaxTokens(8000)
            ->usingTemperature(0.7)
            ->withClientOptions([
                'timeout' => 180,
                'connect_timeout' => 30,
            ])
            ->generate();

        // Build HTML from the slides created via tools
        $htmlSlides = $slideBuilder->buildHtml();

        return [
            'totalSlides' => count($htmlSlides),
            'slides' => $htmlSlides,
        ];
    }

    protected function buildPlanningPrompt(string $title, string $content, ?string $scripture, array $formData): string
    {
        $prompt = "Create a slide deck plan for this presentation:\n\n";
        $prompt .= "TITLE: {$title}\n";
        $prompt .= "CONTENT:\n{$content}\n\n";
        $prompt .= "TARGET SLIDE COUNT: {$formData['slide_count']}\n";
        $prompt .= "THEME: {$formData['theme']}\n\n";

        if ($scripture) {
            $prompt .= "PRIMARY SCRIPTURE: {$scripture}\n\n";
        }

        if (! empty($formData['additional_instructions'])) {
            $prompt .= "SPECIAL INSTRUCTIONS: {$formData['additional_instructions']}\n\n";
        }

        $prompt .= "Return a JSON object with this structure:\n";
        $prompt .= "{\n";
        $prompt .= "  \"totalSlides\": number,\n";
        $prompt .= "  \"slides\": [\n";
        $prompt .= "    {\n";
        $prompt .= "      \"slideNumber\": 1,\n";
        $prompt .= "      \"type\": \"title|outline|content|scripture|conclusion\",\n";
        $prompt .= "      \"title\": \"Slide title\",\n";
        $prompt .= "      \"content\": \"Brief description of slide content\",\n";
        $prompt .= "      \"hasImage\": true|false,\n";
        $prompt .= "      \"imageDescription\": \"Description for image search if hasImage is true\"\n";
        $prompt .= "    }\n";
        $prompt .= "  ]\n";
        $prompt .= "}\n\n";
        $prompt .= 'Return ONLY valid JSON, no other text.';

        return $prompt;
    }

    protected function buildPlanningSystemPrompt(): string
    {
        return "You are an expert presentation designer specializing in creating engaging slide decks.\n\n".
            "Create a well-structured slide plan that:\n".
            "- Opens with a compelling title slide\n".
            "- Includes an outline/overview slide\n".
            "- Breaks main points into digestible slides\n".
            "- Includes scripture slides for key verses (if applicable)\n".
            "- Uses images strategically for visual impact\n".
            "- Ends with a strong conclusion/call to action\n\n".
            'Return valid JSON only.';
    }

    protected function buildToolBasedPrompt(string $title, string $content, ?string $scripture, array $formData, array $themeConfig): string
    {
        $prompt = "Create a slide deck for this presentation using the provided tools:\n\n";
        $prompt .= "TITLE: {$title}\n";
        $prompt .= "CONTENT:\n{$content}\n\n";
        $prompt .= "TARGET SLIDE COUNT: {$formData['slide_count']}\n\n";

        if ($scripture) {
            $prompt .= "PRIMARY SCRIPTURE: {$scripture}\n\n";
        }

        if (! empty($formData['additional_instructions'])) {
            $prompt .= "SPECIAL INSTRUCTIONS: {$formData['additional_instructions']}\n\n";
        }

        $prompt .= "THEME COLORS:\n";
        $prompt .= "- Background gradient: {$themeConfig['background']}\n";
        $prompt .= "- Text color: {$themeConfig['text']}\n";
        $prompt .= "- Primary: {$themeConfig['primary']}\n";
        $prompt .= "- Accent: {$themeConfig['accent']}\n\n";

        $prompt .= "INSTRUCTIONS:\n";
        $prompt .= "1. Use createSlide() to create each new slide with the background gradient\n";
        $prompt .= "2. Use addHeading() for titles (h1 for main titles, h2 for subtitles)\n";
        $prompt .= "3. Use addText() for paragraph content\n";
        $prompt .= "4. Use addBulletPoints() for lists of key points\n";
        $prompt .= "5. Use addQuote() for scripture verses or quotations\n";
        $prompt .= "6. Use white (#FFFFFF) for all text colors for best contrast\n";
        $prompt .= "7. Title slides should use h1 at 64px\n";
        $prompt .= "8. Content slides should use h2 at 48px for headings, 28px for text\n";
        $prompt .= "9. Create engaging, well-structured slides that flow logically\n\n";

        $prompt .= 'Start creating the slides now using the tools!';

        return $prompt;
    }

    protected function buildToolBasedSystemPrompt(): string
    {
        return "You are an expert presentation designer. Use the provided tools to build professional, engaging slides.\n\n".
            "Best practices:\n".
            "- Title slide: Large h1 heading with presentation title\n".
            "- Content slides: h2 heading + supporting text or bullet points\n".
            "- Scripture slides: Use addQuote() with the verse and citation\n".
            "- Keep text concise and readable\n".
            "- Use bullet points for lists of 3-5 items\n".
            "- Ensure good visual hierarchy with font sizes\n".
            "- Use the theme's gradient background for all slides\n".
            '- White text (#FFFFFF) works best on gradient backgrounds';
    }

    protected function extractJsonFromResponse(string $response): array
    {
        if (preg_match('/\{[\s\S]*\}/', $response, $matches)) {
            $json = json_decode($matches[0], true);
            if ($json) {
                return $json;
            }
        }

        throw new \Exception('Could not parse JSON from AI response');
    }

    protected function generateSlideHtml(array $slideData, array $themeConfig): string
    {
        $type = $slideData['type'] ?? 'content';
        $title = $slideData['title'] ?? '';
        $content = $slideData['content'] ?? '';

        // Generate HTML directly without tool calling to avoid Gemini compatibility issues
        try {
            $prompt = $this->buildSimpleSlidePrompt($slideData, $themeConfig);
            $systemPrompt = $this->buildSimpleSystemPrompt();

            $modelConfig = config('study-ai.models.text');

            $response = Prism::text()
                ->using($modelConfig['provider'], $modelConfig['model'])
                ->withSystemPrompt($systemPrompt)
                ->withPrompt($prompt)
                ->withMaxTokens(1000)
                ->usingTemperature(0.7)
                ->withClientOptions([
                    'timeout' => 30,
                    'connect_timeout' => 10,
                ])
                ->generate();

            return $response->text;
        } catch (\Exception $e) {
            \Log::error('Slide generation failed: '.$e->getMessage());

            return $this->getFallbackHtml($type, $title, $content, $themeConfig);
        }
    }

    protected function getSlideGenerationTools(): array
    {
        return [
            [
                'type' => 'function',
                'function' => [
                    'name' => 'create_slide_html',
                    'description' => 'Creates HTML content for a presentation slide with proper structure and styling',
                    'parameters' => [
                        'type' => 'object',
                        'properties' => [
                            'html_content' => [
                                'type' => 'string',
                                'description' => 'The complete HTML content for the slide using semantic tags (h1, h2, p, ul, li)',
                            ],
                            'layout_type' => [
                                'type' => 'string',
                                'enum' => ['centered', 'left-aligned', 'two-column'],
                                'description' => 'The layout structure for the slide',
                            ],
                        ],
                        'required' => ['html_content', 'layout_type'],
                    ],
                ],
            ],
            [
                'type' => 'function',
                'function' => [
                    'name' => 'search_image',
                    'description' => 'Search for an appropriate background image for the slide',
                    'parameters' => [
                        'type' => 'object',
                        'properties' => [
                            'search_query' => [
                                'type' => 'string',
                                'description' => 'Descriptive search query for the image (e.g., "sunset over mountains", "cross with light rays")',
                            ],
                            'style' => [
                                'type' => 'string',
                                'enum' => ['photographic', 'illustration', 'abstract'],
                                'description' => 'The visual style of the image needed',
                            ],
                        ],
                        'required' => ['search_query'],
                    ],
                ],
            ],
            [
                'type' => 'function',
                'function' => [
                    'name' => 'fetch_scripture',
                    'description' => 'Fetch the full text of a Bible verse or passage',
                    'parameters' => [
                        'type' => 'object',
                        'properties' => [
                            'reference' => [
                                'type' => 'string',
                                'description' => 'Bible verse reference (e.g., "John 3:16", "Romans 8:28-30")',
                            ],
                            'version' => [
                                'type' => 'string',
                                'enum' => ['NIV', 'KJV', 'ESV', 'NKJV'],
                                'description' => 'Bible translation version',
                            ],
                        ],
                        'required' => ['reference'],
                    ],
                ],
            ],
        ];
    }

    protected function handleToolCall($toolCall, array $slideData, array $themeConfig): string
    {
        $functionName = $toolCall->name;
        $arguments = $toolCall->arguments();

        return match ($functionName) {
            'create_slide_html' => $this->handleCreateSlideHtml($arguments, $themeConfig),
            'search_image' => $this->handleSearchImage($arguments),
            'fetch_scripture' => $this->handleFetchScripture($arguments),
            default => '',
        };
    }

    protected function handleCreateSlideHtml(array $args, array $themeConfig): string
    {
        $htmlContent = $args['html_content'] ?? '';
        $layoutType = $args['layout_type'] ?? 'left-aligned';

        $wrapperClass = match ($layoutType) {
            'centered' => 'flex flex-col items-center justify-center h-full text-center px-16',
            'two-column' => 'flex gap-12 h-full px-20 py-16',
            default => 'flex flex-col h-full px-20 py-16',
        };

        return "<div class=\"{$wrapperClass}\">{$htmlContent}</div>";
    }

    protected function handleSearchImage(array $args): string
    {
        $query = $args['search_query'] ?? '';

        if (empty($query)) {
            return '';
        }

        // This will be picked up by the main loop to set background
        $this->lastImageSearch = [
            'query' => $query,
            'style' => $args['style'] ?? 'photographic',
        ];

        return '';
    }

    protected function handleFetchScripture(array $args): string
    {
        $reference = $args['reference'] ?? '';
        $version = $args['version'] ?? 'NIV';

        if (empty($reference)) {
            return '';
        }

        try {
            // Use Bible API to fetch the verse
            $response = Http::get('https://bible-api.com/'.urlencode($reference), [
                'translation' => strtolower($version),
            ]);

            if ($response->successful()) {
                $data = $response->json();
                $text = $data['text'] ?? $reference;
                $cleanText = trim(preg_replace('/\s+/', ' ', $text));

                return "<blockquote class=\"scripture-text\" style=\"font-size: {$this->themeConfig['body_font_size']}; font-style: italic; margin: 40px 0;\">{$cleanText}</blockquote><p class=\"scripture-reference\" style=\"text-align: right; font-size: {$this->themeConfig['subtitle_font_size']}; opacity: 0.8;\">— {$reference} ({$version})</p>";
            }
        } catch (\Exception $e) {
            \Log::warning('Failed to fetch scripture: '.$e->getMessage());
        }

        return "<p class=\"scripture-reference\" style=\"font-size: {$this->themeConfig['subtitle_font_size']};\">{$reference}</p>";
    }

    protected function buildSimpleSlidePrompt(array $slideData, array $themeConfig): string
    {
        $type = $slideData['type'] ?? 'content';
        $title = $slideData['title'] ?? '';
        $description = $slideData['content'] ?? '';
        $background = $themeConfig['background'];

        $prompt = "Generate a complete, standalone HTML document for a presentation slide.\n\n";
        $prompt .= "SLIDE TYPE: {$type}\n";
        $prompt .= "TITLE: {$title}\n";
        $prompt .= "CONTENT: {$description}\n\n";

        $prompt .= "THEME COLORS:\n";
        $prompt .= "- Background: {$background}\n";
        $prompt .= "- Text: {$themeConfig['text']}\n";
        $prompt .= "- Primary: {$themeConfig['primary']}\n";
        $prompt .= "- Accent: {$themeConfig['accent']}\n\n";

        $prompt .= "REQUIRED STRUCTURE:\n";
        $prompt .= "- Complete HTML5 document with <!DOCTYPE html>\n";
        $prompt .= "- Include <html>, <head>, and <body> tags\n";
        $prompt .= "- Add meta charset and viewport tags\n";
        $prompt .= "- Include <title> tag with slide title\n";
        $prompt .= "- Embed ALL CSS in <style> tag in <head>\n";
        $prompt .= "- Slide should be 1280px × 720px (16:9)\n";
        $prompt .= "- Use position: absolute layout\n";
        $prompt .= "- Apply gradient background: {$background}\n\n";

        if ($type === 'title') {
            $prompt .= "TITLE SLIDE DESIGN:\n";
            $prompt .= "- Large centered h1 (64px+)\n";
            $prompt .= "- Optional subtitle\n";
            $prompt .= "- Decorative elements (lines, shapes)\n";
            $prompt .= "- Dramatic, impactful layout\n";
        } elseif ($type === 'scripture') {
            $prompt .= "SCRIPTURE SLIDE DESIGN:\n";
            $prompt .= "- Centered blockquote for verse\n";
            $prompt .= "- Citation at bottom-right\n";
            $prompt .= "- Large, readable text (36px+)\n";
            $prompt .= "- Reverent, clean design\n";
        } elseif ($type === 'outline') {
            $prompt .= "OUTLINE SLIDE DESIGN:\n";
            $prompt .= "- h2 title at top\n";
            $prompt .= "- Numbered or bulleted list\n";
            $prompt .= "- Clear hierarchy\n";
            $prompt .= "- Generous spacing\n";
        } else {
            $prompt .= "CONTENT SLIDE DESIGN:\n";
            $prompt .= "- h2 title\n";
            $prompt .= "- Body text or bullet points\n";
            $prompt .= "- Visual elements if appropriate\n";
            $prompt .= "- Balanced layout\n";
        }

        $prompt .= "\nSTYLE REQUIREMENTS:\n";
        $prompt .= "- Font: 'Source Sans Pro' or similar\n";
        $prompt .= "- White text on gradient background\n";
        $prompt .= "- Text shadows for readability\n";
        $prompt .= "- Professional, modern design\n";
        $prompt .= "- Generous padding and spacing\n\n";

        $prompt .= 'Return ONLY the complete HTML document, nothing else.';

        return $prompt;
    }

    protected function buildSimpleSystemPrompt(): string
    {
        return "You are an expert presentation designer creating complete HTML slide documents.\n\n".
            "Generate professional, standalone HTML5 documents that:\n".
            "- Are complete with DOCTYPE, html, head, and body tags\n".
            "- Have embedded CSS styling in the head\n".
            "- Use 1280×720px dimensions (16:9 aspect ratio)\n".
            "- Feature modern, clean design with gradient backgrounds\n".
            "- Have white text with shadows for readability\n".
            "- Use professional fonts like Source Sans Pro\n".
            "- Are visually balanced and impactful\n\n".
            'Return ONLY the complete HTML document, no explanations or markdown.';
    }

    protected function buildSlideContentPrompt(array $slideData, array $themeConfig): string
    {
        $prompt = "Create a presentation slide using the available tools:\n\n";
        $prompt .= "SLIDE TYPE: {$slideData['type']}\n";
        $prompt .= "TITLE: {$slideData['title']}\n";
        $prompt .= "CONTENT DESCRIPTION: {$slideData['content']}\n";

        if ($this->sermon) {
            $prompt .= "SERMON CONTEXT: {$this->sermon->title}\n";
        }

        if ($slideData['hasImage'] ?? false) {
            $prompt .= "IMAGE NEEDED: {$slideData['imageDescription']}\n";
        }

        $prompt .= "\nTHEME COLORS:\n";
        $prompt .= "- Primary: {$themeConfig['primary']}\n";
        $prompt .= "- Secondary: {$themeConfig['secondary']}\n";
        $prompt .= "- Accent: {$themeConfig['accent']}\n";
        $prompt .= "- Text: {$themeConfig['text']}\n\n";

        // Provide specific instructions based on slide type
        if (($slideData['type'] ?? '') === 'scripture') {
            $prompt .= "This is a SCRIPTURE slide. You MUST:\n";
            $prompt .= "1. Use fetch_scripture tool to get the actual Bible verse text\n";
            $prompt .= "2. Use create_slide_html to format it beautifully with centered layout\n";
            $prompt .= "3. Consider using search_image to find a reverent background image\n\n";

            if ($this->sermon && $this->sermon->primary_scripture) {
                $prompt .= "Scripture reference: {$this->sermon->primary_scripture}\n";
            }
        } elseif (($slideData['type'] ?? '') === 'title') {
            $prompt .= "This is a TITLE slide. You MUST:\n";
            $prompt .= "1. Use create_slide_html with 'centered' layout\n";
            $prompt .= "2. Make the title large and impactful (use h1)\n";
            $prompt .= "3. Consider using search_image for a powerful background\n";
        } else {
            $prompt .= "Use the tools to create this slide:\n";
            $prompt .= "1. create_slide_html: Generate semantic HTML (h2 for title, p/ul/li for content)\n";
            $prompt .= "2. search_image: If the content would benefit from a background image\n";
        }

        $prompt .= "\nMake the slide visually balanced, easy to read, and engaging!";

        return $prompt;
    }

    protected function buildSlideContentSystemPrompt(): string
    {
        return "You are an expert presentation designer who creates engaging, visually balanced slide content.\n\n".
            "You have access to powerful tools to help you create slides:\n".
            "- create_slide_html: Generate semantic HTML with proper layout\n".
            "- search_image: Find appropriate background images\n".
            "- fetch_scripture: Get actual Bible verse text\n\n".
            "For each slide, use the appropriate tools:\n".
            "1. Use create_slide_html to generate the main content\n".
            "2. Use search_image if a background image would enhance the message\n".
            "3. Use fetch_scripture for scripture slides to get the actual verse text\n\n".
            "Design principles:\n".
            "- Clear and easy to read from a distance\n".
            "- Visually balanced with proper hierarchy\n".
            "- Concise - use bullet points and short phrases\n".
            "- Semantically structured with proper HTML tags\n\n".
            'Always use the tools provided rather than generating HTML directly.';
    }

    protected function getFallbackHtml(string $type, string $title, string $content, array $themeConfig): string
    {
        $background = $themeConfig['background'];
        $text = $themeConfig['text'];

        $html = "<!DOCTYPE html>\n";
        $html .= "<html lang=\"en\">\n";
        $html .= "<head>\n";
        $html .= "    <meta charset=\"UTF-8\">\n";
        $html .= "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
        $html .= "    <title>{$title}</title>\n";
        $html .= "    <link href=\"https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap\" rel=\"stylesheet\">\n";
        $html .= "    <style>\n";
        $html .= "        * { margin: 0; padding: 0; box-sizing: border-box; }\n";
        $html .= "        body { font-family: 'Source Sans Pro', sans-serif; overflow: hidden; }\n";
        $html .= "        .slide { width: 1280px; height: 720px; position: relative; overflow: hidden; }\n";
        $html .= "        .background { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: {$background}; }\n";
        $html .= "        .content { position: relative; z-index: 10; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 0 100px; text-align: center; color: {$text}; }\n";
        $html .= "        h1 { font-size: 64px; font-weight: 700; margin-bottom: 24px; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }\n";
        $html .= "        h2 { font-size: 48px; font-weight: 600; margin-bottom: 20px; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }\n";
        $html .= "        p { font-size: 28px; line-height: 1.6; max-width: 80%; }\n";
        $html .= "    </style>\n";
        $html .= "</head>\n";
        $html .= "<body>\n";
        $html .= "    <div class=\"slide\">\n";
        $html .= "        <div class=\"background\"></div>\n";
        $html .= "        <div class=\"content\">\n";

        $html .= match ($type) {
            'title' => "            <h1>{$title}</h1>\n",
            'scripture' => "            <h2>{$title}</h2>\n            <p style=\"font-style: italic;\">{$content}</p>\n",
            default => "            <h2>{$title}</h2>\n            <p>{$content}</p>\n",
        };

        $html .= "        </div>\n";
        $html .= "    </div>\n";
        $html .= "</body>\n";
        $html .= '</html>';

        return $html;
    }

    protected function generateSlideStyles(array $themeConfig): string
    {
        return "
            * {
                font-family: {$themeConfig['font_family']};
                box-sizing: border-box;
            }

            body {
                color: {$themeConfig['text']};
            }

            h1 {
                font-size: {$themeConfig['title_font_size']};
                font-weight: 700;
                margin: 0;
                color: {$themeConfig['text']};
            }

            h2 {
                font-size: {$themeConfig['subtitle_font_size']};
                font-weight: 600;
                margin: 0;
                color: {$themeConfig['text']};
            }

            p, li {
                font-size: {$themeConfig['body_font_size']};
                line-height: 1.6;
                color: {$themeConfig['text']};
            }

            .text-primary { color: {$themeConfig['primary']}; }
            .text-secondary { color: {$themeConfig['secondary']}; }
            .text-accent { color: {$themeConfig['accent']}; }
        ";
    }

    protected function downloadImage(string $description): ?string
    {
        if (! config('slides.images.unsplash.enabled')) {
            \Log::info('Unsplash disabled in config');

            return null;
        }

        try {
            $accessKey = config('slides.images.unsplash.access_key');

            if (! $accessKey) {
                \Log::warning('Unsplash access key not configured');

                return null;
            }

            \Log::info("Searching Unsplash for: {$description}");

            $response = Http::get('https://api.unsplash.com/search/photos', [
                'query' => $description,
                'per_page' => 1,
                'orientation' => 'landscape',
                'client_id' => $accessKey,
            ]);

            if ($response->successful()) {
                $results = $response->json('results');

                if (empty($results)) {
                    \Log::warning("No Unsplash results found for: {$description}");

                    return null;
                }

                $photo = $results[0];

                if (isset($photo['links']['download_location'])) {
                    Http::get($photo['links']['download_location'], [
                        'client_id' => $accessKey,
                    ]);
                }

                $this->lastImageAttribution = [
                    'photographer_name' => $photo['user']['name'] ?? 'Unknown',
                    'photographer_url' => $photo['user']['links']['html'] ?? null,
                    'photo_url' => $photo['links']['html'] ?? null,
                    'unsplash_url' => 'https://unsplash.com',
                ];

                $imageUrl = $photo['urls']['regular'] ?? null;
                \Log::info("Successfully found Unsplash image: {$imageUrl}");

                return $imageUrl;
            } else {
                \Log::error('Unsplash API error: '.$response->status().' - '.$response->body());
            }
        } catch (\Exception $e) {
            \Log::error('Failed to download Unsplash image: '.$e->getMessage());
        }

        return null;
    }

    protected function updateProgress(string $cacheKey, int $current, int $total, string $message): void
    {
        Cache::put("{$cacheKey}_progress", [
            'current' => $current,
            'total' => $total,
            'message' => $message,
            'percentage' => round(($current / $total) * 100),
        ], now()->addMinutes(10));
    }
}
